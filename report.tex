% Copyright (c) 2026 Frankie Feng-Cheng WANG. All rights reserved.
% Repository: https://github.com/FrankieeW/formalising-mathematics-notes

%----------------------------------------------------------------------------------------
% Coursework/Project Requirements
% What is the mark scheme?
% Here is the thought experiment.
% Consider an external examiner (a professor from another UK
% university).
% They have heard of Lean and that know it’s a “theorem prover”.
% They have no idea how it works.
% What would they think of your project?
% Would they be able to understand something about what you
% are doing?
% Would they think “this is pretty cool, we should be teaching this
% at my university”?
%
% For the first project. I am looking for:
% ▶ some Lean code (150–200 lines of code including
% comments? More if you like?)
% ▶ A pdf explaining what is going on (5 pages? More if you
% like?)
% You won’t get penalised for doing too much (but it will take
% longer).
% I’m expecting about 15 (or more) hours of work.
%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
  % UTF8, % Encoding %not needed
  12pt, % Default font size, values between 10pt-12pt are allowed
  % letterpaper, % Uncomment for US letter paper size, the default paper size is a4paper
  % Chinese, % Uncomment for Chinese document
]{assignment}

% Set table of contents depth to section level only (no subsection, subsubsection)
\setcounter{tocdepth}{1}
\setcounter{secnumdepth}{2} % Still number sections up to subsubsection, just don't show in TOC

\usepackage{amsthm} % For proof environment
\newtheorem{lemma}{Lemma} % define lemma environment

% Definition environment matching problem environment style from assignment.cls
% Using framed environment like the problem environment in assignment.cls
% \newenvironment{mydef}
%   {\begin{framed}}
%   {\end{framed}}

% \usepackage{pdfpages} % 用于插入 PDF
\usepackage{fontspec}
\usepackage{float}
\setmonofont{FreeMono}
\usepackage{hyperref} % ← 必须显式、提前
\usepackage{minted}
\newmintinline[lean]{lean4}{bgcolor=white}
\newminted[leancode]{lean4}{fontsize=\footnotesize,breaklines,breakanywhere,tabsize=4,showspaces=false}
\newcommand{\leancodeurl}{}
\newcommand{\setleancodeurl}[1]{\renewcommand{\leancodeurl}{#1}}
\renewcommand{\theFancyVerbLine}{\arabic{FancyVerbLine}}
\renewcommand{\FancyVerbFormatLine}[1]{\href{\leancodeurl\#L\arabic{FancyVerbLine}}{#1}}

% Original environment for inline code (deprecated, use leancodefile instead)
\newenvironment{leancodegit}[3][]{\VerbatimEnvironment\setleancodeurl{#3}\begin{leancode}[#1]}{\end{leancode}}

% New command to import code directly from .lean files
% Usage: \leancodefile[minted options]{local/path/to/file.lean}{github_url}
% Example: \leancodefile[firstline=20,lastline=25]{../lean/GroupAction/Defs.lean}{https://github.com/.../Defs.lean}
\newcommand{\leancodefile}[3][]{%
  \setleancodeurl{#3}%
  \inputminted[fontsize=\footnotesize,breaklines,breakanywhere,tabsize=4,showspaces=false,linenos=true,#1]{lean4}{#2}%
}

\usemintedstyle{tango}
% \usepackage{hyperref}
% \usepackage{embedfile}
% \usepackage{appendix}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{xcolor}
\newcommand\nb{\addtocounter{equation}{1}\tag{\theequation}}
\pgfplotsset{compat=1.18}
% \renewcommand{\thesection}{Exercise \arabic{section}}


%-------------------------------------------------------------------------------
% ASSIGNMENT INFORMATION
%-------------------------------------------------------------------------------

% Fix for fancyhdr warning: increase headheight and adjust topmargin
\setlength{\headheight}{29.34845pt}
\addtolength{\topmargin}{-17.34845pt}

\title{Formalizing Group Action in Lean} % Assignment title
\author{Frankie Feng-Cheng WANG} % Student name
% \studentid{219046894} % Student id Leicester
\email{maths@frankie.wang} % Student email
\github{https://github.com/FrankieeW/GroupAction} % GitHub URL
\date{\today} % Due date
\institute{Department of Mathematics\\Imperial College London} % Institute or school name
\course{MATH70040-Formalising Mathematics} % Course or class name
\lecturer{Dr Bhavik Mehta} % Lecturer or teacher in charge of the assignment

%----------------------------------------------------------------------------------------
\begin{document}
\setcounter{tocdepth}{3}
\maketitle % Output the assignment title, created automatically using the information in the custom commands above
\tableofcontents

%----------------------------------------------------------------------------------------
% ASSIGNMENT CONTENT
%----------------------------------------------------------------------------------------
\section{Introduction}

This report presents a Lean~4 formalisation of \textbf{group actions}.
The development is organised around three closely related components:

\begin{enumerate}
	\item \textbf{Core definitions:} the \texttt{GroupAction} typeclass, together with
	      the notions of faithfulness and transitivity;
	\item \textbf{Concrete examples:} a selection of standard group actions illustrating
	      the abstract definitions;
	\item \textbf{Key theorems:} the construction of the permutation representation
	      associated to a group action and the subgroup structure of stabilisers.
\end{enumerate}

The mathematical development and theorem numbering follow
Fraleigh and Katz, \textit{A First Course in Abstract Algebra},
Addison-Wesley, 2003, Section~16 (Group Actions).

The complete Lean source code is available on GitHub:
\begin{center}
	\url{https://github.com/FrankieeW/GroupAction}
\end{center}

\subsection{Running the Code}
To verify the formalization, use Lake to build and run the Lean code:
\begin{verbatim}
lake build                    # Build the project
lake env lean lean/GroupAction.lean    # Run the main file
lake env lean lean/GroupAction/Examples.lean  # Check all examples
\end{verbatim}

All code snippets appearing in this report are hyperlinked to the corresponding
lines in the repository.

The principal results formalised in this project are stated below and proved in
later sections.

\begin{quote}
	\textbf{Theorem~16.3.}
	Let $X$ be a $G$-set. For each $g \in G$, the map
	\[
		\sigma_g : X \to X, \qquad \sigma_g(x) = g \cdot x,
	\]
	is a permutation of $X$. Moreover, the assignment
	\[
		\phi : G \to \mathrm{Sym}(X), \qquad \phi(g) = \sigma_g,
	\]
	is a group homomorphism, and for all $g \in G$ and $x \in X$,
	\[
		\phi(g)(x) = g \cdot x.
	\]
\end{quote}

\begin{quote}
	\textbf{Theorem~16.12.}
	Let $X$ be a $G$-set and let $x \in X$. The stabiliser of $x$ in $G$,
	defined by
	\[
		G_x = \{\, g \in G \mid g \cdot x = x \,\},
	\]
	is a subgroup of $G$.
\end{quote}


\iffalse%
	\section{Background and Design Choices}
	\subsection{Why a custom action class}
	Mathlib already provides \texttt{MulAction}, but I define a small custom class
	\texttt{GroupAction} with just two axioms: compatibility with multiplication and
	the identity action. This keeps the development minimal and makes it easy to map
	Lean lines to textbook lines. The cost is that I cannot use existing \texttt{MulAction}
	lemmas, but the benefit is transparency.

	\subsection{What Lean is checking}
	Lean treats each statement as a typed object. When I define \texttt{sigmaPerm}, Lean
	checks that the inverse function is a two-sided inverse. When I define \texttt{phi},
	Lean checks that its image lies in the group \texttt{Equiv.Perm X} and that
	multiplication is permutation composition. This explicit checking prevents hidden
	gaps that can slip into informal proofs.
\fi

\section{Definitions}
This section introduces the group action class and the definitions of faithful and transitive actions.
\subsection{Group Action}\label{sec:group-action-definition}%
Now, we present the definition of a group action both mathematically and in Lean.
\begin{table}[H]
	\centering
	\begin{tabular}[t]{p{0.47\textwidth}@{\hspace{2em}}p{0.47\textwidth}}

		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Mathematical definition.}

			A \textbf{group action} of a group $G$ on a set $X$ is a map
			\[
				\cdot : G \times X \to X,
			\]
			satisfying, for all $g_1,g_2\in G$ and $x\in X$:
			\begin{itemize}
				\item (Compatibility) $(g_1 g_2)\cdot x = g_1\cdot(g_2\cdot x)$;
				\item (Identity) $1\cdot x = x$.
			\end{itemize}
		\end{minipage}
		 &
		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Lean formalisation.}

			The following Lean code defines a (left) action of a monoid $G$ on a type $X$.
			\begin{itemize}
				\item \texttt{act : G → X → X} represents the action $g\cdot x$;
				\item \texttt{ga\_mul} encodes compatibility with multiplication;
				\item \texttt{ga\_one} states that the identity acts trivially.
			\end{itemize}
		\end{minipage}
	\end{tabular}
\end{table}


\bigskip

\leancodefile[
	firstline=13,
	lastline=21,
	firstnumber=13
]{../lean/GroupAction/Defs.lean}
{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Defs.lean}

Using \texttt{Monoid} instead of \texttt{Group} allows the action to be defined
for monoids in general. The inverse element is not needed for the axioms.
However, I will only consider group actions in this project.
\leancodefile[firstline=13,lastline=13,firstnumber=13]{../lean/GroupAction/Basic.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Basic.lean}
\subsection{Faithful and transitive actions}

\paragraph{Faithful actions.}
An action of a group $G$ on a set $X$ is said to be \textbf{faithful} if distinct
group elements induce distinct permutations of $X$. Equivalently, the action is
faithful if
\[
	(\forall x \in X,\; g_1 \cdot x = g_2 \cdot x) \;\Longrightarrow\; g_1 = g_2.
\]

In other words, no nontrivial group element acts trivially on all of $X$.

\leancodefile[
	firstline=25,
	lastline=26,
	firstnumber=25
]{../lean/GroupAction/Defs.lean}
{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Defs.lean}

\paragraph{Transitive actions.}
An action of a group $G$ on a set $X$ is \textbf{transitive} if for any
$x_1, x_2 \in X$, there exists an element $g \in G$ such that
\[
	g \cdot x_1 = x_2.
\]

This means that $X$ consists of a single orbit under the action of $G$.

\leancodefile[
	firstline=33,
	lastline=34,
	firstnumber=33
]{../lean/GroupAction/Defs.lean}
{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Defs.lean}

\section{Concrete Examples of Group Actions}
This section presents several concrete instances of the \texttt{GroupAction} class,
illustrating how the abstract definition applies to familiar mathematical structures.

\subsection{Symmetric group acting on a set}
Let $X$ be any type. The symmetric group $\mathrm{Sym}(X)$ acts on $X$ by evaluation:
for $\sigma \in \mathrm{Sym}(X)$ and $x \in X$, define $\sigma \cdot x := \sigma(x)$.

\leancodefile[firstline=21,lastline=28,firstnumber=21]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}

The axiom proofs are immediate by reflexivity: composition of permutations and function
evaluation commute definitionally in Lean.

Two standard properties of this action are faithful and transitive:
\leancodefile[firstline=30,lastline=43,firstnumber=30]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}
The instance \texttt{DecidableEq X} is required because \texttt{Equiv.swap} constructs a
permutation by branching on whether two elements are equal, which needs decidable equality.

\subsection{Group acting on itself by left multiplication}
Every group $G$ acts on itself by left multiplication: $g_1 \cdot g_2 := g_1 * g_2$.

\leancodefile[firstline=46,lastline=54,firstnumber=46]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}

The \texttt{ga\_mul} axiom follows from associativity of group multiplication, and
\texttt{ga\_one} from the identity axiom.

\subsection{Subgroup acting on the group}
A subgroup $H \leq G$ acts on $G$ by left multiplication. Elements of $H$ are coerced
to elements of $G$ using \texttt{(h : G)}.

\leancodefile[firstline=58,lastline=66,firstnumber=58]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}

The \texttt{simp} tactic handles the coercion and applies associativity and identity axioms.

\subsection{Conjugation action of a subgroup on itself}
A subgroup $H$ acts on itself by conjugation: $h_1 \cdot h_2 := h_1 h_2 h_1^{-1}$.

\leancodefile[firstline=68,lastline=79,firstnumber=68]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}
% mul_assoc.{u_1} {G : Type u_1} [Semigroup G] (a b c : G) : a * b * c = a * (b * c)
The \texttt{mul\_assoc} lemma is from mathlib and states associativity of multiplication:

\begin{minted}[fontsize=\footnotesize,breaklines,breakanywhere]{lean4}
mul_assoc.{u_1} {G : Type u_1} [Semigroup G] (a b c : G) :
a * b * c = a * (b * c)
\end{minted}



The \texttt{ga\_mul} proof can easily be done by \texttt{simp [mul\_assoc]}, but I expanded it to show the steps explicitly by using \texttt{rw}.



For example the \texttt{rw [← mul\_assoc $g_1$]} will aotumatically find the passible situation looks like \texttt{$g_1$* (b * c)}, because we only give one argument \texttt{$g_1$} to \texttt{← mul\_assoc}.
% $g_1 * (g_2 * g_3 * g_2^{-1})$ -> $g_1 * (g_2 * g_3) * g_2^{-1}$
In detail, it will rewrite the left hand side \texttt{$g_1$ * ($g_2$ * $g_3$ * $g_2^{-1}$)} to \texttt{$g_1$ * ($g_2$ * $g_3$) * $g_2^{-1}$} according to the right to left direction of the lemma \texttt{mul\_assoc}.
\subsection{Scalar action on complex vector spaces}
The multiplicative group $\mathbb{C}^\times$ of nonzero complex numbers acts on
$\mathbb{C}^n$ by scalar multiplication.

\leancodefile[firstline=83,lastline=95,firstnumber=83]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}

Here \texttt{ℂˣ} denotes the units of $\mathbb{C}$ (invertible elements), and
\texttt{Fin n → ℂ} represents functions from $\{0, \ldots, n-1\}$ to $\mathbb{C}$
(i.e., $n$-dimensional complex vectors). The \texttt{ext} tactic proves function equality
pointwise.
\iffalse % The reprot is too long
	\subsection{Scalar action via units}
	The unit group $\alpha^\times$ of a monoid $\alpha$ acts on $\alpha^n$ by scalar multiplication.

	\leancodefile[firstline=103,lastline=115,firstnumber=103]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}

	This generalizes the complex example by abstracting over the coefficient monoid.
\fi
\subsection{Dihedral group action on a square}
Let $D_4$ be the symmetry group of a square, acting on $\mathbb{Z}/4\mathbb{Z}$.

\leancodefile[firstline=130,lastline=170,firstnumber=130]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}
\iffalse % The report is too long
	\subsection{Symmetric group $S_3$ acting on \{1,2,3\}}
	The symmetric group on 3 elements provides the canonical example of a transitive group action. This is the standard permutation representation of $S_3$.

	\leancodefile[firstline=173,lastline=180,firstnumber=173]{../lean/GroupAction/Examples.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Examples.lean}

	The action is transitive: for any two elements $a, b \in \{1,2,3\}$, there exists a permutation $\sigma \in S_3$ such that $\sigma(a) = b$.
\fi
\section{Permutation Representation}
The core construction is the map $\sigma_g : X \to X$ given by $\sigma_g(x) = g \cdot x$.
The inverse of $\sigma_g$ is $\sigma_{g^{-1}}$, so $\sigma_g$ is a permutation.
This yields the permutation representation $\phi : G \to \mathrm{Sym}(X)$.

\subsection{Proof Path}
To establish the permutation representation, we follow these steps:

\begin{enumerate}
	\item \textbf{Define the action map:} For each $g \in G$, construct $\sigma_g : X \to X$ by $\sigma_g(x) = g \cdot x$.
	\item \textbf{Prove $\sigma_g$ is a bijection:} Show that $\sigma_g$ has an inverse, namely $\sigma_{g^{-1}}$.
	\item \textbf{Construct the permutation:} Package $\sigma_g$ as an element of $\mathrm{Sym}(X)$ using the inverse.
	\item \textbf{Define the representation:} Set $\phi(g) = \sigma_g$ to get $\phi : G \to \mathrm{Sym}(X)$.
	\item \textbf{Verify homomorphism properties:} Prove that $\phi$ preserves multiplication and the identity.
\end{enumerate}

\subsection{Step-by-Step Proof with Mathematical and Code Explanations}
We now walk through each step in detail, providing both mathematical reasoning and the corresponding Lean code.

\subsubsection{Step 1: Define the action map $\sigma_g$}
This step may not be strictly necessary in Lean code, but we include it to align with traditional mathematical proof structure, showing how the action map is constructed before proving its properties.

\begin{table}[H]
	\centering
	\begin{tabular}[t]{p{0.47\textwidth}@{\hspace{2em}}p{0.47\textwidth}}

		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Mathematical explanation.}

			For each group element $g \in G$, we define a function $\sigma_g : X \to X$ that applies the group action: $\sigma_g(x) = g \cdot x$. This is simply the action function partially applied to $g$.
		\end{minipage}
		 &
		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Lean code explanation.}

			The function \texttt{sigma} implements this definition. It takes a group element \texttt{g} and returns a function from \texttt{X} to \texttt{X} that applies the action.
		\end{minipage}
	\end{tabular}
\end{table}

\leancodefile[firstline=27,lastline=30,firstnumber=27]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

\subsubsection{Step 2: Prove $\sigma_g$ is a bijection}
Lean requires an explicit construction of the inverse function to show that $\sigma_g$ is a permutation.
\begin{table}[H]
	\centering
	\begin{tabular}[t]{p{0.47\textwidth}@{\hspace{2em}}p{0.47\textwidth}}

		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Mathematical explanation.}

			To show $\sigma_g$ is bijective, we need both injectivity and surjectivity. The key insight is that the inverse operation $g^{-1}$ provides the inverse function: $\sigma_{g^{-1}} \circ \sigma_g = \mathrm{id}_X$ and $\sigma_g \circ \sigma_{g^{-1}} = \mathrm{id}_X$. This follows from the group axioms and the action compatibility.
		\end{minipage}
		 &
		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Lean code explanation.}

			The \texttt{sigmaPerm} definition constructs a permutation by providing both the forward function (\texttt{toFun := sigma g}) and its inverse (\texttt{invFun := sigma $g^{-1}$}). The proofs of \texttt{left\_inv} and \texttt{right\_inv} verify the two-sided inverse properties using the action axioms.
		\end{minipage}
	\end{tabular}
\end{table}

\leancodefile[firstline=32,lastline=65,firstnumber=32]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

\subsubsection{Step 3: Construct the permutation representation $\phi$}
This step bridges the individual permutations $\sigma_g$ to a group homomorphism, constructing the representation map $\phi : G \to \mathrm{Sym}(X)$ that preserves the group structure.

\begin{table}[H]
	\centering
	\begin{tabular}[t]{p{0.47\textwidth}@{\hspace{2em}}p{0.47\textwidth}}

		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Mathematical explanation.}

			Having established that each $\sigma_g$ is a permutation, we can define the representation map $\phi : G \to \mathrm{Sym}(X)$ by $\phi(g) = \sigma_g$. This assignment preserves the action: $\phi(g)(x) = \sigma_g(x) = g \cdot x$.
		\end{minipage}
		 &
		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Lean code explanation.}

			The function \texttt{phi} simply wraps \texttt{sigmaPerm}, and \texttt{phi\_apply} confirms that it agrees with the original action.
		\end{minipage}
	\end{tabular}
\end{table}

\leancodefile[firstline=67,lastline=73,firstnumber=67]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

\subsubsection{Step 4: Verify homomorphism properties}
This step establishes that $\phi$ is a group homomorphism by verifying it preserves multiplication and the identity element, completing the proof that $\phi$ is a valid group representation.

\begin{table}[H]
	\centering
	\begin{tabular}[t]{p{0.47\textwidth}@{\hspace{2em}}p{0.47\textwidth}}

		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Mathematical explanation.}

			For $\phi$ to be a group homomorphism, we need $\phi(g_1 g_2) = \phi(g_1) \phi(g_2)$ and $\phi(1) = 1$. The multiplication property follows from the action compatibility axiom: $\phi(g_1 g_2)(x) = (g_1 g_2) \cdot x = g_1 \cdot (g_2 \cdot x) = \phi(g_1)(\phi(g_2)(x))$.
		\end{minipage}
		 &
		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Lean code explanation.}

			The lemmas \texttt{phi\_mul} and \texttt{phi\_one} prove these properties. \texttt{phi\_mul} uses \texttt{Equiv.ext} for extensionality and applies the \texttt{ga\_mul} axiom, while \texttt{phi\_one} uses the \texttt{ga\_one} axiom.
		\end{minipage}
	\end{tabular}
\end{table}

\leancodefile[firstline=79,lastline=100,firstnumber=79]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

\subsubsection{Step 5: Package the theorem}
Now just need to combine everything into the final theorem statement.
\begin{table}[H]
	\centering
	\begin{tabular}[t]{p{0.47\textwidth}@{\hspace{2em}}p{0.47\textwidth}}

		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Mathematical explanation.}

			We now have all the ingredients: a homomorphism $\phi$ that satisfies the required properties. This completes the construction of the permutation representation.
		\end{minipage}
		 &
		\begin{minipage}[t]{0.47\textwidth}
			\textbf{Lean code explanation.}

			The theorem \texttt{group\_action\_to\_perm\_representation} packages everything together, using the previously proved lemmas to construct the existential witness.
		\end{minipage}
	\end{tabular}
\end{table}

\leancodefile[firstline=102,lastline=114,firstnumber=102]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

\subsection{Proof sketch (informal)}
To show that $\sigma_g$ is a bijection, compute
$\sigma_{g^{-1}}(\sigma_g(x)) = (g^{-1} g) \cdot x = 1 \cdot x = x$, and similarly
$\sigma_g(\sigma_{g^{-1}}(x)) = x$. The representation is defined by
$\phi(g) = \sigma_g$, and multiplicativity follows from the action axiom:
\[
	\phi(g_1 g_2)(x) = (g_1 g_2) \cdot x = g_1 \cdot (g_2 \cdot x) = (\phi(g_1)\phi(g_2))(x).
\]

\subsection{Lean code}
First, define the underlying action map:
\leancodefile[firstline=26,lastline=29,firstnumber=26]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

Then package it as a permutation using the inverse action:
\leancodefile[firstline=34,lastline=64,firstnumber=34]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}
Using \texttt{\#check} on \texttt{sigmaPerm} confirms it has type
\leancodefile[firstline=65,lastline=65,firstnumber=65]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}
This confirms the map $g \mapsto \sigma_g$ is a well-defined function from $G$ to $\mathrm{Sym}(X)$.
Define the representation and its basic properties:
\leancodefile[firstline=69,lastline=100,firstnumber=69]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

Finally, package the existence statement:
\leancodefile[firstline=103,lastline=108,firstnumber=103]{../lean/GroupAction/Permutation.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Permutation.lean}

\section{Stabilizers}
For a fixed $x \in X$, the stabilizer is the subset
\[
	G_x = \{ g \in G \mid g \cdot x = x \}.
\]
In Lean this is first defined as a set, then shown to be the carrier of a subgroup,
and finally packaged as a \texttt{Subgroup}.

\subsection{Proof sketch (informal)}
The identity element fixes every $x$, so $1 \in G_x$. If $g_1$ and $g_2$ fix $x$, then
$(g_1 g_2)\cdot x = g_1 \cdot (g_2 \cdot x) = g_1 \cdot x = x$, so $g_1 g_2 \in G_x$.
If $g$ fixes $x$, then
$g^{-1} \cdot x = g^{-1} \cdot (g \cdot x) = (g^{-1} g) \cdot x = x$,
so $g^{-1} \in G_x$.

\subsection{Lean code}
Start from the set definition:
\leancodefile[firstline=24,lastline=25,firstnumber=24]{../lean/GroupAction/Stabilizer.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Stabilizer.lean}

Package it as a subgroup by checking closure:
% 加一段介绍 carrier one_mem mul_mem inv_mem
Define the subgroup structure by providing proofs of the subgroup axioms:
\begin{itemize}
	\item \texttt{carrier}: the underlying set is \texttt{stabilizerSet x}.
	\item \texttt{one\_mem'}: the identity fixes every $x$ by the \texttt{ga\_one} axiom.
	\item \texttt{mul\_mem'}: if $g_1$ and $g_2$ fix $x$, then so does $g_1 g_2$ by the
	      \texttt{ga\_mul} axiom.
	\item \texttt{inv\_mem'}: if $g$ fixes $x$, then so does $g^{-1}$ by combining
	      \texttt{ga\_mul} and \texttt{ga\_one}.
\end{itemize}
\leancodefile[firstline=28,lastline=52,firstnumber=28]{../lean/GroupAction/Stabilizer.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Stabilizer.lean}

Then show the set is the carrier of a subgroup:
\leancodefile[firstline=55,lastline=57,firstnumber=55]{../lean/GroupAction/Stabilizer.lean}{https://github.com/FrankieeW/GroupAction/blob/v1.2.0/lean/GroupAction/Stabilizer.lean}

\iffalse%
	\section{Main Theorem}
	The Lean theorem \texttt{group\_action\_to\_perm\_representation} packages the permutation
	representation together with its key properties. The proof uses the lemmas from the
	previous section: \texttt{phi\_apply}, \texttt{phi\_mul}, and \texttt{phi\_one}.
\fi

\section{What Lean Guarantees}
Formalizing these constructions in Lean provides guarantees that informal proofs cannot match.
When Lean accepts a definition or theorem, it has verified:
\begin{itemize}
	\item \textbf{Types are correct.} The function \texttt{phi : G → Equiv.Perm X} has the claimed type.
	      Lean checks that \texttt{sigmaPerm g} is actually a permutation (a bijection), not just a function.
	      If we mistakenly defined a non-bijective map, Lean would reject it.
	\item \textbf{No hidden assumptions.} Every lemma explicitly lists its hypotheses. If a proof uses
	      associativity, the code must invoke \texttt{mul\_assoc} or the \texttt{ga\_mul} axiom.
	      There are no ``clearly'' or ``it follows that'' steps that skip justification.
	\item \textbf{Axioms match definitions.} The \texttt{GroupAction} class requires \texttt{ga\_mul}
	      and \texttt{ga\_one}. If we omitted \texttt{ga\_one}, the proof of \texttt{phi\_one} would fail
	      because Lean would have no way to show $1 \cdot x = x$.
	\item \textbf{Subgroup structure is verified.} When we package the stabilizer as a \texttt{Subgroup},
	      Lean checks that we provided proofs of closure under multiplication, inverses, and identity.
	      The type system prevents us from claiming ``the stabilizer is a subgroup'' without proving it.
\end{itemize}

These checks prevent common errors: mistaken claims about injectivity, forgotten hypotheses,
and gaps in subgroup proofs. An external examiner can trust that the Lean code genuinely establishes
the mathematical claims, not just that it compiles.

\section{Reflection}
Writing the proofs in Lean forced me to make every step explicit. In particular:
\begin{itemize}
	\item I had to show explicitly that $\sigma_{g^{-1}}$ is an inverse.
	\item I had to unfold the definition of permutation multiplication.
\end{itemize}
The resulting code is not shorter than a textbook proof, but it is more precise.
An external examiner can read the surrounding explanations and then see that each
Lean line matches a specific mathematical claim.


\subsection{Specific challenges encountered about formalization}
Several technical hurdles emerged during the formalization:
\begin{itemize}
	\item \textbf{Typeclass resolution:} Ensuring Lean could automatically find the \texttt{GroupAction}
	      instance in complex contexts required careful use of explicit type annotations (e.g., \texttt{(G := G)}).
	\item \textbf{Equivalence mechanics:} Constructing \texttt{sigmaPerm} as an \texttt{Equiv.Perm X}
	      required providing both \texttt{left\_inv} and \texttt{right\_inv} proofs, which meant carefully
	      applying the \texttt{ga\_mul} axiom in both directions.
	\item \textbf{Coercions:} Working with subgroups required understanding how Lean coerces elements
	      of type \texttt{H} (a subgroup) to type \texttt{G} (the ambient group) using \texttt{(h : G)}.
	\item \textbf{Function extensionality:} Proving equality of permutations required \texttt{Equiv.ext},
	      and equality of vector-valued functions required \texttt{ext i}, which were not immediately obvious.
	\item \textbf{Decidable equality:} Some examples (like the symmetric group action) required
	      \texttt{DecidableEq} instances to construct certain permutations, which added complexity.
	      % \item I tried to add `mul_assoc` to `simp` because my proof used `simp [mul_assoc]` many times, but I later realised that `simp` does not include `mul_assoc` by design: changing the order of multiplication does not constitute a genuine simplification, since associativity merely rearranges the expression rather than making it simpler.
	\item \textbf{mul\_assoc usage:} I initially attempted to add \texttt{mul\_assoc} to the \texttt{simp} set
	      because I used \texttt{simp [mul\_assoc]} frequently. However, I later realized that \texttt{simp}
	      does not include \texttt{mul\_assoc} by design: changing the order of multiplication does not
	      constitute a genuine simplification, since associativity merely rearranges the expression rather
	      than making it simpler.
\end{itemize}
% 代码规范性上的
\subsection{Specific challenges encountered about code structure and style}
During the development, I faced several challenges related to code structure and style:
\begin{itemize}
	\item \textbf{Modularization:} Deciding how to split the code into multiple files (e.g., \texttt{Defs.lean},
	      \texttt{Examples.lean}, \texttt{Permutation.lean}, \texttt{Stabilizer.lean}) required careful
	      consideration of dependencies and logical flow.
	\item \textbf{Naming conventions:} Choosing clear and consistent names for definitions,
	      lemmas, and instances was crucial for readability but sometimes challenging.
	\item \textbf{Documentation:} Balancing inline comments with external documentation to ensure
	      that both the code and the report were understandable without redundancy.
	\item \textbf{Tactic selection:} Deciding when to use high-level tactics like \texttt{simp} versus
	      more explicit steps with \texttt{rw} and \texttt{calc} for clarity.
\end{itemize}
% 还有选题高级过于简单 没有用很多 rintro 等高级tactic
\section{Conclusion}
This formalization establishes the foundational concepts of group actions in Lean,
including the permutation representation and stabilizers.

\subsection{Code Quality Verification}
All Lean code in this project has been verified to pass \texttt{\#lint} checks, ensuring high code quality and adherence to best practices:

\begin{itemize}
	\item \textbf{Documentation completeness}: All definitions, theorems, and instances have proper documentation strings
	\item \textbf{No unused variables}: All declared variables are used in their respective contexts
	\item \textbf{No dead code}: All code paths are reachable and meaningful
	\item \textbf{Style consistency}: Code follows consistent naming conventions and formatting
	\item \textbf{Type safety}: No unsafe type coercions or suppressions
\end{itemize}

The project configuration in \texttt{lakefile.toml} enables comprehensive linter checks, and all files compile without warnings when running \texttt{lake build} with \texttt{linter.all = true}. This ensures the formalization is not only mathematically correct but also maintainable and follows community standards.
\iffalse%
	\subsection{Potential extensions}
	This development could be extended in several directions:
	\begin{itemize}
		\item \textbf{Orbit-stabilizer theorem:} Formalize the relationship $|G| = |\text{Orb}(x)| \cdot |G_x|$
		      for finite groups, which requires defining orbits and proving Lagrange's theorem.
		\item \textbf{Burnside's lemma:} Count orbits using the formula involving fixed points.
		\item \textbf{Actions on cosets:} Show that a group acts on the left cosets of a subgroup,
		      yielding the standard permutation representation.
		\item \textbf{Cayley's theorem:} Specialize the permutation representation to the case where
		      $G$ acts on itself, proving every group embeds in a symmetric group.
	\end{itemize}


	\section{Relation to Mathlib's \texttt{MulAction}}
	Mathlib's \texttt{MulAction} class provides a general framework for monoid actions, which is mathematically equivalent to our \texttt{GroupAction} class. The key differences are philosophical and structural rather than mathematical:

	\begin{itemize}
		\item \textbf{Mathematical equivalence}: Both classes define actions $G \times X \to X$ satisfying $(g_1 g_2) \cdot x = g_1 \cdot (g_2 \cdot x)$ and $1 \cdot x = x$.

		\item \textbf{Type class requirements}: \texttt{MulAction} requires a \texttt{Monoid} $G$, while our \texttt{GroupAction} also requires a \texttt{Monoid} $G$ (technically, this makes them equivalent).

		\item \textbf{Emphasis on groups}: Our \texttt{GroupAction} class is designed specifically for group actions, with definitions like faithfulness and transitivity that assume group properties (e.g., inverses).

		\item \textbf{Extensibility}: The custom class allows us to add group-specific theorems and examples without modifying Mathlib's general-purpose classes.
	\end{itemize}

	This custom class serves as a foundation for group theory development while remaining compatible with Mathlib's ecosystem.
\fi

\section{Future Extensions}
This formalization provides a foundation for further development in group action theory. Potential extensions include: the orbit-stabilizer theorem relating the size of orbits to cosets of stabilizers; Burnside's lemma for counting group elements with fixed points; group actions on cosets, leading to the concept of permutation representations; and applications to representation theory and algebraic topology.
\section{References}
John B. Fraleigh, Victor J. Katz, \textit{A First Course in Abstract Algebra},
Addison-Wesley, 2003, Section 16 (Group Actions).

\appendix
\part{Appendix}
\section{AI Assistance Statement}
I used AI-assisted tools in a limited and strictly auxiliary manner. Specifically, AI was used to help automate the conversion of Lean source files into \LaTeX\ code blocks for inclusion in this report, and to assist with reorganising a single Lean file into multiple smaller files during the development process. In addition, AI was occasionally used for high-level brainstorming about structure and presentation.
Additionally, C. Project Configuration and Build Instructions is generated with AI.

All mathematical content, Lean definitions, proofs, and formal statements were written, checked, and verified by me. AI tools were not used to replace mathematical reasoning or to generate unverified results. I take full responsibility for the correctness and originality of both the Lean code and the written exposition.



\section{Lean Tactics Glossary}
This section provides a brief explanation of the key Lean tactics used in the proofs throughout this formalization.

\begin{itemize}
	\item \textbf{\texttt{intro}}: Introduces assumptions into the local context. For example, \texttt{intro g x} brings a group element $g$ and a set element $x$ into scope for a proof.

	\item \textbf{\texttt{apply}}: Applies a lemma or theorem to the current goal. For example, \texttt{apply ga\_mul} uses the group action multiplication axiom.

	\item \textbf{\texttt{simp}}: Simplifies expressions using equational lemmas and basic rules. For example, \texttt{simp} might simplify $(g_1 g_2) \cdot x$ to $g_1 \cdot (g_2 \cdot x)$ using associativity.

	\item \textbf{\texttt{rw}}: Rewrites the goal or hypotheses using an equality. For example, \texttt{rw [ga\_one]} rewrites using the identity axiom.

	\item \textbf{\texttt{calc}}: Structures multi-step equalities in a readable way. For example, \texttt{calc} blocks break down complex equality proofs into clear steps.

	\item \textbf{\texttt{ext}}: Proves equality of functions by proving they agree on all inputs. For example, \texttt{ext x} proves two functions are equal by showing they produce the same output for every $x$.

	\item \textbf{\texttt{exact}}: Closes a goal by providing an exact term that matches the goal type. For example, \texttt{exact rfl} proves $x = x$.

	\item \textbf{\texttt{refine}}: Partially constructs a term, leaving holes for subgoals. For example, \texttt{refine \{ act := fun g x => g x, ga\_mul := ?\_ \}} constructs a GroupAction instance with a hole for the multiplication proof.

	\item \textbf{\texttt{constructor}}: Builds values of inductive types. For example, \texttt{constructor} might construct an \texttt{Equiv.Perm X} by providing the forward and inverse functions.
\end{itemize}

These tactics form the core toolkit for interactive theorem proving in Lean. Each tactic has precise semantics and helps build formal proofs step by step.

\section{Project Configuration and Build Instructions}
This section documents the project setup, configuration, and build process for reproducibility.

\subsection{Project Structure}
The project follows a modular organization:
\begin{verbatim}
GroupAction/
├── lean/                     # Lean 4 source files
│   ├── GroupAction.lean      # Main entry point
│   └── GroupAction/          # Core modules
│       ├── Defs.lean         # GroupAction class + axioms
│       ├── Basic.lean        # Basic lemmas (faithful, transitive)
│       ├── Permutation.lean  # phi : G → Equiv.Perm X
│       ├── Stabilizer.lean   # Stabilizer subgroup Gₓ
│       └── Examples.lean     # Instances and #check tests
├── tex/                      # LaTeX report + figures
├── doc/                      # Project documentation
├── lakefile.toml             # Lake configuration
├── lean-toolchain            # Pinned Lean version
└── README.md                 # Project overview
\end{verbatim}

\subsection{Lake Configuration}
The project uses Lake (Lean's build system) with the following key configuration in \texttt{lakefile.toml}:

\begin{verbatim}
[leanOptions]
pp.unicode.fun = true          # Enable Unicode function notation
autoImplicit = false           # Disable automatic implicit arguments
relaxedAutoImplicit = false    # Strict implicit argument handling
linter.style.longLine = true   # Enable long line linter

# Additional linter options (recommended for code quality)
linter.all = true              # Enable all recommended linters
linter.missingDocs = true      # Check for missing documentation
linter.unusedVariables = true  # Check for unused variables
linter.unusedArguments = true  # Check for unused arguments
linter.deadCode = true         # Check for dead code
\end{verbatim}

% \subsection{Build Commands}
% \begin{verbatim}
% # Setup (first time)
% lake exe cache get            # Download mathlib cache (~30s)

% # Build commands
% lake build                     # Full project build
% lake env lean -- lake build    # Build with explicit Lean environment

% # Test commands
% lake env lean lean/GroupAction/Examples.lean
% lake env lean lean/GroupAction/Defs.lean
% lake env lean lean/GroupAction/Basic.lean
% lake env lean lean/GroupAction/Permutation.lean
% lake env lean lean/GroupAction/Stabilizer.lean
% lake env lean lean/GroupAction.lean
% \end{verbatim}


\subsection{Dependencies}
\begin{itemize}
	\item \textbf{Lean 4}: Version 4.27.0 (pinned in \texttt{lean-toolchain})
	\item \textbf{mathlib}: Version 4.27.0 (via Lake)
	\item \textbf{LaTeX}: XeLaTeX with \texttt{minted} package for code highlighting
\end{itemize}



This configuration ensures reproducible builds, consistent code quality, and clear documentation throughout the project lifecycle.


\end{document}
